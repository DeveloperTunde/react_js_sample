{"ast":null,"code":"/*\nCopyright (c) 2019 Daybrush\nname: @scena/react-ruler\nlicense: MIT\nauthor: Daybrush\nrepository: https://github.com/daybrush/ruler/blob/master/packages/react-ruler\nversion: 0.7.4\n*/\nimport { createElement, PureComponent } from 'react';\nimport { ref } from 'framework-utils';\nimport { convertUnitSize } from '@daybrush/utils';\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\n\n/* global Reflect, Promise */\n\nvar extendStatics = function (d, b) {\n  extendStatics = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (d, b) {\n    d.__proto__ = b;\n  } || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n  };\n\n  return extendStatics(d, b);\n};\n\nfunction __extends(d, b) {\n  extendStatics(d, b);\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\n\nvar Ruler = /*#__PURE__*/function (_super) {\n  __extends(Ruler, _super);\n\n  function Ruler() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.state = {\n      scrollPos: 0\n    };\n    _this.width = 0;\n    _this.height = 0;\n    return _this;\n  }\n\n  var __proto = Ruler.prototype;\n\n  __proto.render = function () {\n    return createElement(\"canvas\", {\n      ref: ref(this, \"canvasElement\"),\n      style: this.props.style\n    });\n  };\n\n  __proto.componentDidMount = function () {\n    var canvas = this.canvasElement;\n    var context = canvas.getContext(\"2d\");\n    this.canvasContext = context;\n    this.resize();\n  };\n\n  __proto.componentDidUpdate = function () {\n    this.resize();\n  };\n  /**\n   * @method Ruler#scroll\n   * @param scrollPos\n   */\n\n\n  __proto.scroll = function (scrollPos) {\n    this.draw(scrollPos);\n  };\n  /**\n   * @method Ruler#resize\n   */\n\n\n  __proto.resize = function () {\n    var canvas = this.canvasElement;\n    var _a = this.props,\n        width = _a.width,\n        height = _a.height,\n        scrollPos = _a.scrollPos;\n    this.width = width || canvas.offsetWidth;\n    this.height = height || canvas.offsetHeight;\n    canvas.width = this.width * 2;\n    canvas.height = this.height * 2;\n    this.draw(scrollPos);\n  };\n\n  __proto.draw = function (scrollPos) {\n    if (scrollPos === void 0) {\n      scrollPos = this.state.scrollPos;\n    }\n\n    var props = this.props;\n    var _a = props,\n        unit = _a.unit,\n        zoom = _a.zoom,\n        type = _a.type,\n        backgroundColor = _a.backgroundColor,\n        lineColor = _a.lineColor,\n        textColor = _a.textColor,\n        direction = _a.direction,\n        _b = _a.negativeRuler,\n        negativeRuler = _b === void 0 ? true : _b,\n        textFormat = _a.textFormat;\n    var width = this.width;\n    var height = this.height;\n    var state = this.state;\n    state.scrollPos = scrollPos;\n    var context = this.canvasContext;\n    var isHorizontal = type === \"horizontal\";\n    var isDirectionStart = direction === \"start\";\n    var isNegative = negativeRuler !== false;\n    var textAlign = props.textAlign || \"left\";\n    var textOffset = props.textOffset || [0, 0];\n    var containerSize = isHorizontal ? height : width;\n    var mainLineSize = convertUnitSize(\"\" + (props.mainLineSize || \"100%\"), containerSize);\n    var longLineSize = convertUnitSize(\"\" + (props.longLineSize || 10), containerSize);\n    var shortLineSize = convertUnitSize(\"\" + (props.shortLineSize || 7), containerSize);\n\n    if (backgroundColor === \"transparent\") {\n      // Clear existing paths & text\n      context.clearRect(0, 0, width * 2, height * 2);\n    } else {\n      // Draw the background\n      context.rect(0, 0, width * 2, height * 2);\n      context.fillStyle = backgroundColor;\n      context.fill();\n    }\n\n    context.save();\n    context.scale(2, 2);\n    context.strokeStyle = lineColor;\n    context.lineWidth = 1;\n    context.font = \"10px sans-serif\";\n    context.fillStyle = textColor;\n\n    if (isDirectionStart) {\n      context.textBaseline = \"top\";\n    }\n\n    context.translate(0.5, 0);\n    context.beginPath();\n    var size = isHorizontal ? width : height;\n    var zoomUnit = zoom * unit;\n    var minRange = Math.floor(scrollPos * zoom / zoomUnit);\n    var maxRange = Math.ceil((scrollPos * zoom + size) / zoomUnit);\n    var length = maxRange - minRange;\n    var alignOffset = Math.max([\"left\", \"center\", \"right\"].indexOf(textAlign) - 1, -1);\n\n    for (var i = 0; i <= length; ++i) {\n      var value = i + minRange;\n\n      if (!isNegative && value < 0) {\n        continue;\n      }\n\n      var startPos = (value * unit - scrollPos) * zoom;\n\n      for (var j = 0; j < 10; ++j) {\n        var pos = startPos + j / 10 * zoomUnit;\n\n        if (pos < 0 || pos >= size) {\n          continue;\n        }\n\n        var lineSize = j === 0 ? mainLineSize : j % 2 === 0 ? longLineSize : shortLineSize;\n\n        var _c = isHorizontal ? [pos, isDirectionStart ? 0 : height - lineSize] : [isDirectionStart ? 0 : width - lineSize, pos],\n            x1 = _c[0],\n            y1 = _c[1];\n\n        var _d = isHorizontal ? [x1, y1 + lineSize] : [x1 + lineSize, y1],\n            x2 = _d[0],\n            y2 = _d[1];\n\n        context.moveTo(x1, y1);\n        context.lineTo(x2, y2);\n      }\n\n      if (startPos >= -zoomUnit && startPos < size + unit * zoom) {\n        var _e = isHorizontal ? [startPos + alignOffset * -3, isDirectionStart ? 17 : height - 17] : [isDirectionStart ? 17 : width - 17, startPos + alignOffset * 3],\n            startX = _e[0],\n            startY = _e[1];\n\n        var text = \"\" + value * unit;\n\n        if (textFormat) {\n          text = textFormat(value * unit);\n        }\n\n        context.textAlign = textAlign;\n\n        if (isHorizontal) {\n          context.fillText(text, startX + textOffset[0], startY + textOffset[1]);\n        } else {\n          context.save();\n          context.translate(startX + textOffset[0], startY + textOffset[1]);\n          context.rotate(-Math.PI / 2);\n          context.fillText(text, 0, 0);\n          context.restore();\n        }\n      }\n    }\n\n    context.stroke();\n    context.restore();\n  };\n\n  Ruler.defaultProps = {\n    type: \"horizontal\",\n    zoom: 1,\n    width: 0,\n    height: 0,\n    unit: 50,\n    negativeRuler: true,\n    mainLineSize: \"100%\",\n    longLineSize: 10,\n    shortLineSize: 7,\n    direction: \"end\",\n    style: {\n      width: \"100%\",\n      height: \"100%\"\n    },\n    backgroundColor: \"#333333\",\n    textColor: \"#ffffff\",\n    lineColor: \"#777777\"\n  };\n  return Ruler;\n}(PureComponent);\n\nvar PROPERTIES = [\"type\", \"width\", \"height\", \"unit\", \"zoom\", \"style\", \"backgroundColor\", \"lineColor\", \"textColor\", \"direction\", \"textFormat\", \"scrollPos\", \"textAlign\", \"mainLineSize\", \"longLineSize\", \"shortLineSize\", \"negativeRuler\", \"textOffset\"];\nvar METHODS = [\"scroll\", \"resize\"];\nexport default Ruler;\nexport { METHODS, PROPERTIES };","map":{"version":3,"sources":["../src/react-ruler/Ruler.tsx","../src/react-ruler/consts.ts"],"names":["tslib_1","Ruler","type","zoom","width","height","unit","negativeRuler","mainLineSize","longLineSize","shortLineSize","direction","style","backgroundColor","textColor","lineColor","_this","scrollPos","ref","canvas","context","_a","props","_b","textFormat","state","isHorizontal","isDirectionStart","isNegative","textAlign","textOffset","containerSize","convertUnitSize","size","zoomUnit","minRange","Math","maxRange","length","alignOffset","i","value","startPos","j","pos","lineSize","_c","x1","y1","_d","x2","y2","_e","startX","startY","text","PROPERTIES","METHODS"],"mappings":"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","sourcesContent":["import * as React from \"react\";\nimport { ref } from \"framework-utils\";\nimport { RulerInterface, RulerProps } from \"./types\";\nimport { convertUnitSize } from \"@daybrush/utils\";\n\nexport default class Ruler extends React.PureComponent<RulerProps> implements RulerInterface {\n    public static defaultProps: RulerProps = {\n        type: \"horizontal\",\n        zoom: 1,\n        width: 0,\n        height: 0,\n        unit: 50,\n        negativeRuler: true,\n        mainLineSize: \"100%\",\n        longLineSize: 10,\n        shortLineSize: 7,\n        direction: \"end\",\n        style: { width: \"100%\", height: \"100%\" },\n        backgroundColor: \"#333333\",\n        textColor: \"#ffffff\",\n        lineColor: \"#777777\",\n    };\n    public divisionsElement!: HTMLElement;\n    public state = {\n        scrollPos: 0,\n    };\n    public canvasElement!: HTMLCanvasElement;\n    private canvasContext!: CanvasRenderingContext2D;\n    private width: number = 0;\n    private height: number = 0;\n    public render() {\n        return (<canvas\n            ref={ref(this, \"canvasElement\")}\n            style={this.props.style} />);\n\n    }\n    public componentDidMount() {\n        const canvas = this.canvasElement;\n        const context = canvas.getContext(\"2d\")!;\n\n        this.canvasContext = context;\n\n        this.resize();\n    }\n    public componentDidUpdate() {\n        this.resize();\n    }\n    /**\n     * @method Ruler#scroll\n     * @param scrollPos\n     */\n    public scroll(scrollPos: number) {\n        this.draw(scrollPos);\n    }\n    /**\n     * @method Ruler#resize\n     */\n    public resize() {\n        const canvas = this.canvasElement;\n        const {\n            width,\n            height,\n            scrollPos,\n        } = this.props;\n\n        this.width = width || canvas.offsetWidth;\n        this.height = height || canvas.offsetHeight;\n        canvas.width = this.width * 2;\n        canvas.height = this.height * 2;\n        this.draw(scrollPos);\n    }\n    private draw(scrollPos: number = this.state.scrollPos) {\n        const props = this.props;\n        const {\n            unit,\n            zoom,\n            type,\n            backgroundColor,\n            lineColor,\n            textColor,\n            direction,\n            negativeRuler = true,\n            textFormat,\n        } = props as Required<RulerProps>;\n        const width = this.width;\n        const height = this.height;\n        const state = this.state;\n        state.scrollPos = scrollPos;\n        const context = this.canvasContext;\n        const isHorizontal = type === \"horizontal\";\n        const isDirectionStart = direction === \"start\";\n        const isNegative = negativeRuler !== false;\n        const textAlign = props.textAlign || \"left\";\n        const textOffset = props.textOffset || [0, 0];\n        const containerSize = isHorizontal ? height : width;\n        const mainLineSize = convertUnitSize(`${props.mainLineSize || \"100%\"}`, containerSize);\n        const longLineSize = convertUnitSize(`${props.longLineSize || 10}`, containerSize);\n        const shortLineSize = convertUnitSize(`${props.shortLineSize || 7}`, containerSize);\n\n        if (backgroundColor === \"transparent\") {\n            // Clear existing paths & text\n            context.clearRect(0, 0, width * 2, height * 2);\n        } else {\n            // Draw the background\n            context.rect(0, 0, width * 2, height * 2);\n            context.fillStyle = backgroundColor;\n            context.fill();\n        }\n\n        context.save();\n        context.scale(2, 2);\n        context.strokeStyle = lineColor;\n        context.lineWidth = 1;\n        context.font = \"10px sans-serif\";\n        context.fillStyle = textColor;\n\n        if (isDirectionStart) {\n            context.textBaseline = \"top\";\n        }\n        context.translate(0.5, 0);\n        context.beginPath();\n\n        const size = isHorizontal ? width : height;\n        const zoomUnit = zoom * unit;\n        const minRange = Math.floor(scrollPos * zoom / zoomUnit);\n        const maxRange = Math.ceil((scrollPos * zoom + size) / zoomUnit);\n        const length = maxRange - minRange;\n        const alignOffset = Math.max([\"left\", \"center\", \"right\"].indexOf(textAlign) - 1, -1);\n\n\n\n        for (let i = 0; i <= length; ++i) {\n            const value = i + minRange;\n\n            if (!isNegative && value < 0) {\n                continue;\n            }\n            const startPos = (value * unit - scrollPos) * zoom;\n\n\n            for (let j = 0; j < 10; ++j) {\n                const pos = startPos + j / 10 * zoomUnit;\n\n                if (pos < 0 || pos >= size) {\n                    continue;\n                }\n                const lineSize = j === 0\n                    ? mainLineSize\n                    : (j % 2 === 0 ? longLineSize : shortLineSize);\n\n                const [x1, y1] = isHorizontal\n                    ? [pos, isDirectionStart ? 0 : height - lineSize]\n                    : [isDirectionStart ? 0 : width - lineSize, pos];\n                const [x2, y2] = isHorizontal ? [x1, y1 + lineSize] : [x1 + lineSize, y1];\n                context.moveTo(x1, y1);\n                context.lineTo(x2, y2);\n            }\n\n            if (startPos >= -zoomUnit && startPos < size + unit * zoom) {\n                const [startX, startY] = isHorizontal\n                    ? [startPos + alignOffset * -3, isDirectionStart ? 17 : height - 17]\n                    : [isDirectionStart ? 17 : width - 17, startPos + alignOffset * 3];\n\n                let text = `${value * unit}`;\n\n                if (textFormat) {\n                    text = textFormat(value * unit);\n                }\n\n                context.textAlign = textAlign;\n                if (isHorizontal) {\n                    context.fillText(text, startX + textOffset[0], startY + textOffset[1]);\n                } else {\n                    context.save();\n                    context.translate(startX + textOffset[0], startY + textOffset[1]);\n                    context.rotate(-Math.PI / 2);\n                    context.fillText(text, 0, 0);\n                    context.restore();\n                }\n            }\n        }\n        context.stroke();\n        context.restore();\n    }\n}\n","import { RulerInterface, RulerProps } from \"./types\";\n\nexport const PROPERTIES: Array<keyof RulerProps> = [\n    \"type\", \"width\", \"height\",\n    \"unit\", \"zoom\", \"style\", \"backgroundColor\", \"lineColor\",\n    \"textColor\", \"direction\",\n    \"textFormat\", \"scrollPos\",\n    \"textAlign\",\n    \"mainLineSize\", \"longLineSize\",\n    \"shortLineSize\", \"negativeRuler\",\n    \"textOffset\",\n];\nexport const METHODS: Array<keyof RulerInterface> = [\n    \"scroll\", \"resize\",\n];\n"]},"metadata":{},"sourceType":"module"}